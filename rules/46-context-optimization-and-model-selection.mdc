---
alwaysApply: true
description: 品質/トークン比の最大化を実現するための戦略。リスクベース読み込み、diff優先、Working Summary、モデル選択、役割分担、コンテキスト最適化の自動判断基準を定義します。トークン節約が目的ではなく、トークンあたりの成果品質を最大化する。
---

# 46. コンテキスト最適化とモデル選択戦略 (Context Optimization & Model Selection Strategy)

## 🎯 基本原則 (Core Principles)

**目標**: **品質/トークン比の最大化**（トークン節約が目的ではなく、トークンあたりの成果品質を最大化する）

**常にバランスを取る**:
- **成果品質 (Outcome Quality)**: 正確性、完全性、安全性
- **トークン消費 (Token Consumption)**: 読み込むコンテキスト量
- **再作業リスク (Rework Risk)**: コンテキスト不足による修正の必要性

**絶対に守る**: 正確性や安全性をトークン節約のために犠牲にしてはいけない。

1. **コンテキストは「リスクベースで決定」**: タスクのリスクレベルに応じて読み込み量を決定。低リスクなら最小限、高リスクなら必要十分な範囲を読み込む
2. **モデル選択は「自動」**: ユーザーはモデルを選ばない。AIがタスクの性質に応じて最適なモデルを自動選択
3. **役割分担は「明確」**: 複雑なタスクは分割し、各モデルが明確な役割を持つ
4. **無駄なコンテキスト消費は「全力で排除」**: 重複読み込み、不要なファイル読み込み、過剰な範囲読み込みを徹底的に避ける
5. **デフォルトは「diff優先・最小コンテキスト優先」**: レビューや変更依頼では、git diffや変更箇所のみを優先的に読み込む

---

## 1. コンテキスト最適化戦略 (Context Optimization Strategy)

### 1.0 デフォルトの思考順序 (Default Thinking Order)

**タスク受領時、内部で以下を決定してから応答する**:

1. **目標成果物は何か？** (What is the target artifact?)
   - コード / レビュー / 設計 / 修正 / 計画 など

2. **正確な結果を出すために必要な最小コンテキストは何か？** (What is the minimum context required to produce a correct result?)
   - git diff / 変更ファイルリスト / エラーメッセージ / スタックトレース / 失敗テスト / 特定関数や行範囲 / API契約 / 最小再現ケース

3. **コンテキスト不足の場合のリスクレベルは？** (What is the risk level if context is insufficient?)
   - LOW / MEDIUM / HIGH

4. **どの読み込み戦略を取るか？** (Should I: Scan only / Targeted deep read / Full context read)
   - リスクレベルに応じて決定（後述の「リスクベース読み込みエスカレーション」参照）

### 1.1 ファイル読み込みの優先順位と範囲制限

**原則**: リスクレベルに応じて読み込み量を決定。ファイル全体を読むのは高リスクの場合のみ。

**デフォルト**: リポジトリ全体やファイル全体を要求しない。以下を優先的に要求:
- git diff
- 変更ファイルリスト
- エラーメッセージ
- スタックトレース
- 失敗テスト
- 特定関数や行範囲
- API契約
- 最小再現ケース

**大きなコンテキストが提供された場合**:
→ 即座に「Working Summary」に圧縮し、以降はサマリーを使用（エスカレーションが必要な場合のみ元のコンテキストを再開）

#### 読み込み戦略の判断フロー

```
1. タスクの性質を分析
   ├─ 単一関数/コンポーネントの修正 → 該当箇所のみ（offset/limit使用）
   ├─ 複数ファイルの関連性調査 → grep/codebase_searchで絞り込み → 必要箇所のみ
   ├─ 全体構造の理解 → README/設計書 → 必要ファイルのみ
   └─ レビュー → git diff優先、または変更ファイル + 変更箇所のみ

2. リスクレベルを判定（後述の「リスクベース読み込みエスカレーション」参照）
   ├─ LOW RISK → Scan / Diff Only
   ├─ MEDIUM RISK → Targeted Deep Read
   └─ HIGH RISK → Full Read Allowed

3. 読み込み範囲の決定（リスクレベルに応じて）
   ├─ LOW RISK: git diff、変更箇所のみ、エラーメッセージ周辺のみ
   ├─ MEDIUM RISK: 関連箇所のみ（前後50-100行）、依存関係ファイルの必要箇所
   └─ HIGH RISK: 必要に応じてファイル全体、関連ファイル全体

4. 並列実行の活用
   ├─ 依存関係のない読み込み → 並列実行（multi_tool_use.parallel）
   └─ 依存関係のある読み込み → 順次実行
```

#### 具体的な最適化手法

**✅ DO（推奨）**:
- `read_file` で `offset` と `limit` を指定して必要な範囲のみ読み込む
- `grep` で該当箇所を特定してから、その周辺のみを `read_file` で読み込む
- `codebase_search` で意味的な検索を行い、関連ファイルを特定してから必要箇所のみ読み込む
- 複数の独立したファイル読み込みは並列実行する
- READMEや設計書を先に読んで全体像を把握し、必要なファイルのみに絞り込む

**❌ DON'T（禁止）**:
- 巨大ファイルを全体読み込みする（1000行超のファイルは必ず範囲指定）
- 関連性のないファイルを「念のため」読み込む
- 同じファイルを複数回読み込む（一度読み込んだ内容は再利用）
- 変更対象ファイルだけでなく、関連ファイルも「念のため」全て読み込む

### 1.2 リスクベース読み込みエスカレーション (Risk-Based Reading Escalation)

**リスクレベルに応じて読み込み戦略を決定**:

| リスクレベル | 読み込み戦略 | 例 |
|------------|------------|-----|
| **LOW RISK** | Scan / Diff Only | UI変更、コピー変更、小さなバグ修正、ドキュメント |
| **MEDIUM RISK** | Targeted Deep Read | 機能ロジック変更、リファクタリング、パフォーマンスチューニング、データ変換 |
| **HIGH RISK** | Full Read Allowed | セキュリティ/認証、金融計算、分散状態、並行処理、レガシー統合、アーキテクチャ決定 |

**リスク判定の判断基準**:
- **LOW**: 影響範囲が限定的で、失敗しても影響が小さい
- **MEDIUM**: 影響範囲が中程度で、失敗すると修正が必要だが致命的ではない
- **HIGH**: 影響範囲が広く、失敗すると重大な問題が発生する可能性がある

#### UI/Figma実装の例外ルール
**Figmaリンク指定 / 「SPページ修正」などのUI実装は MEDIUM〜HIGH として扱う。**
理由: 視覚的な差分の取り逃しは再作業コストが高く、品質リスクが大きい。

必須読み込み:
- **全体フレーム（ページ/画面）**の `get_design_context` + `get_screenshot`
- 指定された個別ノードの `get_design_context` + `get_screenshot`
- 既存DOMの該当セクション周辺（ヘッダー/ミッション/フッターなど、関連する隣接セクションを含む）

実装ルール:
- 「部分ノードのみ」で完結させず、**全体フレームで欠落セクションを検知**する
- 画像は **ローカル素材が指定されていれば必ずローカルにマップ**し、FigmaのリモートURLに依存しない

### 1.3 レビュー時のコンテキスト最適化（デフォルト: Diff優先）

**レビューモードのデフォルト**: git diff優先、または変更ファイル + 変更箇所のみ

**レビュー依頼時の優先順位**:

1. **git diff を要求**（変更箇所のみをレビュー）
   OR
2. **変更ファイルリスト + 変更箇所**（diffが取得できない場合）

**レビュー優先順位**:
1. **正確性 (Correctness)**: 要件を満たしているか？バグはないか？
2. **セキュリティ (Security)**: `23-security-policy.mdc` に違反していないか？
3. **パフォーマンス (Performance)**: パフォーマンス問題はないか？
4. **保守性 (Maintainability)**: 可読性、DRY/KISS原則に従っているか？

**diffが不十分な場合のみ**:
- 変更箇所の周辺コードを読み込む（前後50-100行程度）
- 関連ファイルを読み込む（依存関係がある場合のみ）
- 関連ルールを読み込む（レビュー観点に関連するもののみ）

**プロジェクト全体のレビュー依頼の場合**:
```
レビュー対象: プロジェクト全体の評価
├─ Step 1: README.md を読んで全体像を把握（全体読み込み可、ただし200行未満の場合）
├─ Step 2: 主要なエントリーポイントを特定（index.html, main.ts など）
├─ Step 3: 各ページ/機能の主要ファイルを読み込み（範囲指定推奨、リスクレベルに応じて）
├─ Step 4: 関連ルールを読み込み（レビュー観点に関連するもののみ）
└─ Step 5: 問題箇所を特定したら、その周辺のみを詳細に読み込む
```

**レビュー時の並列実行**:
- 複数の独立したファイル読み込みは並列実行
- 複数のルールファイル読み込みは並列実行
- ただし、ファイル間の依存関係がある場合は順次実行

### 1.4 Working Summary プロトコル (Working Summary Protocol)

**大きなコンテキストが提供された場合の圧縮戦略**:

コンテキストが大きくなった場合、以下を作成して以降はサマリーを使用:

```
=== WORKING SUMMARY ===
Goal: <タスクの目標>
Constraints: <制約条件>
Known Facts: <既知の事実>
Unknowns: <不明な点>
Risk Level: LOW / MEDIUM / HIGH
Next Action: <次のアクション>
=======================
```

**サマリー作成後の運用**:
- サマリーを優先的に使用し、元の長いコンテキストは参照しない
- リスクが正当化される場合のみ、元のコンテキストを再開

### 1.5 トークン圧縮ループ (Token Compression Loop)

**会話コンテキストが大きくなった場合**:

1. **Working Summary を生成**
2. **古い参照をタグに置き換え**:
   - `[REQ-1]`: 要件1
   - `[BUG-2]`: バグ2
   - `[FILE-3]`: ファイル3
3. **以降はサマリー + タグで作業を継続**

### 1.6 無駄なコンテキスト消費の排除

**無駄なコンテキスト消費の例と対策**:

| 無駄な消費 | 対策 |
|-----------|------|
| 同じファイルを複数回読み込む | 一度読み込んだ内容は再利用。必要に応じてメモ化 |
| 関連性のないファイルを読み込む | `grep`/`codebase_search` で関連性を確認してから読み込む |
| 巨大ファイルを全体読み込む | `offset`/`limit` で必要な範囲のみ読み込む |
| 変更対象以外のファイルも読み込む | 変更対象ファイルと、その直接の依存関係のみ読み込む |
| 全てのルールファイルを読み込む | タスクに関連するルールのみ読み込む |

---

## 2. モデル選択戦略 (Model Selection Strategy)

### 2.1 タスクタイプ別の最適モデル選択

**原則**: ユーザーはモデルを選ばない。AIがタスクの性質に応じて最適なモデルを自動選択する。

#### タスクタイプの分類とモデル選択

| タスクタイプ | 特徴 | 推奨モデル | 理由 |
|------------|------|-----------|------|
| **コードレビュー** | 静的解析、品質チェック、指摘 | `fast` または `medium` | 迅速な指摘が重要。複雑な推論は不要 |
| **実装・リファクタリング** | コード生成、構造変更 | `medium` または `large` | 正確性と構造理解が必要 |
| **調査・探索** | コードベース探索、仕様確認 | `fast` または `explore` サブエージェント | 広範囲の探索が主。迅速性が重要 |
| **設計・アーキテクチャ** | システム設計、設計判断 | `medium` または `large` | 複雑な推論と判断が必要 |
| **デバッグ** | エラー原因特定、修正 | `medium` | 推論と実装のバランスが必要 |
| **ドキュメント作成** | 仕様書、設計書、コメント | `medium` | 正確性と表現力が必要 |

#### モデル選択の判断フロー

```
1. タスクの性質を分析
   ├─ 迅速性が重要 → fast
   ├─ 正確性が重要 → medium/large
   ├─ 広範囲探索が必要 → fast + exploreサブエージェント
   └─ 複雑な推論が必要 → medium/large

2. コンテキスト量を考慮
   ├─ コンテキストが大きい → fast（トークン節約）
   ├─ コンテキストが小さい → medium/large（品質優先）
   └─ コンテキストが中程度 → medium（バランス）

3. タスクの複雑度を考慮
   ├─ 単純なタスク → fast
   ├─ 中程度のタスク → medium
   └─ 複雑なタスク → large
```

### 2.2 サブエージェント活用による役割分担

**原則**: 複雑なタスクは分割し、各モデルが明確な役割を持つ。

#### 役割分担のパターン

**パターン1: 探索 → 実装**
```
1. fast/exploreサブエージェント: コードベースを探索し、実装箇所を特定
2. mediumメインエージェント: 探索結果を基に実装を実行
```

**パターン2: レビュー → 修正**
```
1. fastサブエージェント: コードをレビューし、問題箇所を特定
2. mediumメインエージェント: レビュー結果を基に修正を実行
```

**パターン3: 調査 → 設計 → 実装**
```
1. fast/exploreサブエージェント: 要件や既存実装を調査
2. mediumサブエージェント: 調査結果を基に設計を立案
3. medium/largeメインエージェント: 設計を基に実装を実行
```

#### サブエージェント使用の判断基準

**✅ サブエージェントを使うべき時**:
- 広範囲の探索が必要な時（`explore` サブエージェント）
- 複数の独立した調査が必要な時（並列実行可能）
- 長時間のリサーチが必要な時（メインコンテキストを節約）

**❌ サブエージェントを使わない時**:
- 単一ファイルの軽微な修正
- 即座に実行できるコマンド
- メインコンテキストで十分対応できるタスク

---

## 3. 実装時の具体的な手順 (Implementation Steps)

### 3.1 タスク受領時の判断フロー（デフォルト思考順序）

```
1. 目標成果物を特定 (What is the target artifact?)
   ├─ コード / レビュー / 設計 / 修正 / 計画 など

2. 正確な結果に必要な最小コンテキストを決定 (What is the minimum context required?)
   ├─ git diff / 変更ファイルリスト / エラーメッセージ / スタックトレース / 失敗テスト
   ├─ 特定関数や行範囲 / API契約 / 最小再現ケース
   └─ リポジトリ全体やファイル全体は要求しない（デフォルト）

3. リスクレベルを判定 (What is the risk level?)
   ├─ LOW RISK → Scan / Diff Only
   ├─ MEDIUM RISK → Targeted Deep Read
   └─ HIGH RISK → Full Read Allowed

4. 読み込み戦略を決定 (Should I: Scan only / Targeted deep read / Full context read)
   ├─ リスクレベルに応じた読み込み範囲を決定
   ├─ 並列実行可能な読み込みを特定
   └─ 必要に応じて Working Summary を作成

5. 役割分担を決定
   ├─ サブエージェントが必要か判断
   ├─ 各モデルの役割を明確化
   └─ 実行順序を決定

6. 実行
   ├─ リスクレベルに応じたコンテキストを読み込む
   ├─ 並列実行を活用
   └─ 無駄な読み込みを排除
```

### 3.2 レビュー時の最適化手順（デフォルト: Diff優先）

**レビュー依頼を受けた場合（デフォルト）**:

```
1. git diff を要求（変更箇所のみをレビュー）
   OR
   変更ファイルリスト + 変更箇所（diffが取得できない場合）

2. diff/変更箇所のみをレビュー
   ├─ 正確性チェック（要件を満たしているか？バグはないか？）
   ├─ セキュリティチェック（`23-security-policy.mdc` に違反していないか？）
   ├─ パフォーマンスチェック
   └─ 保守性チェック（可読性、DRY/KISS原則）

3. 指摘を構造化（[MUST]/[IMO]/[ASK]/[nits]）
   └─ 改善案を提示

4. diffが不十分な場合のみ追加読み込み
   ├─ 変更箇所の周辺コード（前後50-100行）
   └─ 関連ファイル（依存関係がある場合のみ）
```

**プロジェクト全体のレビュー依頼の場合**:

```
1. レビュー対象を特定
   ├─ プロジェクト全体 → README.md を先に読む（200行未満の場合のみ全体読み込み）
   ├─ 特定ファイル → そのファイルと関連ファイルのみ
   └─ 特定機能 → その機能に関連するファイルのみ

2. リスクレベルに応じたコンテキストを読み込む
   ├─ LOW RISK: 主要エントリーポイントのみ（範囲指定）
   ├─ MEDIUM RISK: 主要ファイル + 関連ファイル（範囲指定）
   └─ HIGH RISK: 必要に応じてファイル全体

3. レビュー観点に関連するルールのみを読み込む
   └─ 例: セキュリティレビューなら 23-security-policy.mdc のみ

4. 問題箇所を特定したら、その周辺のみを詳細に読み込む
```

### 3.3 実装時の最適化手順

**実装依頼を受けた場合**:

```
1. 実装範囲を特定
   ├─ 変更対象ファイルを特定
   ├─ 依存関係を特定（grep/codebase_search）
   └─ 関連ルールを特定

2. 最小限のコンテキストを読み込む
   ├─ 変更対象ファイル（必要な範囲のみ）
   ├─ 直接の依存関係ファイル（必要な範囲のみ）
   └─ 関連ルール（実装に関連するもののみ）

3. mediumモデルで実装
   ├─ 設計を決定
   ├─ 実装を実行
   └─ テスト・確認

4. 必要に応じて追加読み込み
   ├─ エラーが発生した場合のみ関連ファイルを読み込む
   └─ 実装後の確認で必要箇所のみ読み込む
```

---

## 4. コンテキスト消費の監視と改善 (Context Consumption Monitoring)

### 4.1 無駄な消費の検出基準

**以下のパターンは無駄な消費として検出**:

1. **同じファイルを複数回読み込む**: 一度読み込んだ内容は再利用する
2. **関連性のないファイルを読み込む**: `grep`/`codebase_search` で関連性を確認してから読み込む
3. **巨大ファイルを全体読み込む**: 1000行超のファイルは必ず範囲指定
4. **変更対象以外のファイルも読み込む**: 変更対象ファイルと直接の依存関係のみ
5. **全てのルールファイルを読み込む**: タスクに関連するルールのみ

### 4.2 改善のための自己チェック

**各タスク完了時に以下をチェック**:

1. **読み込んだファイル数**: 本当に必要だったか？
2. **読み込んだ範囲**: 全体を読む必要があったか？範囲指定できなかったか？
3. **並列実行**: 並列実行できた読み込みがあったか？
4. **重複読み込み**: 同じファイルを複数回読み込んでいないか？
5. **モデル選択**: 最適なモデルを選択できたか？

---

## 5. ユーザーショートタグ対応 (User Short Tags)

**ユーザーが以下のタグを含めた場合、対応するモードを有効化**:

| タグ | 意味 | 動作 |
|------|------|------|
| **【MC】** | Minimal Context Mode | 最小コンテキストモード。diff優先、範囲指定必須、Working Summary優先 |
| **【DIFF】** | Diff First Mode | diff優先モード。git diffまたは変更箇所のみを読み込む |
| **【FASTREV】** | Fast Review Mode | 高速レビューモード。diffのみ、指摘のみ、説明は最小限 |
| **【COMPRESS】** | Force Working Summary | Working Summary強制モード。大きなコンテキストは即座に圧縮 |

**タグの組み合わせ**: 複数のタグを同時に使用可能（例: 【MC】【DIFF】）

## 6. トークン無駄遣いの防止 (Token Waste Prevention)

**❌ してはいけないこと**:
- ユーザーのプロンプトを繰り返す
- 求められていない教育理論や講義を提供する
- 求められていない複数の代替案を生成する
- 埋め合わせの説明を追加する
- 必要以上にスコープを拡大する

**✅ すべきこと**:
- 最小限の完全に使える出力を提供する
- 説明よりも実行可能な結果を優先する

## 7. シングルパスバイアス (Single Pass Bias)

**デフォルト**: 1パスで解決する。

**複数ステップの推論を許可するのは以下の場合のみ**:
- アーキテクチャ設計
- 複雑なデバッグ
- クロスシステム依存関係の推論

## 8. 内部トークン予算の意識 (Internal Token Budget Awareness)

**内部でトークン負荷を推定**:

- **LOW** → 通常実行
- **MEDIUM** → Summary-first実行
- **HIGH** → 強制圧縮 + diff優先 + 最小限の説明

## 9. 品質安全性条項 (Quality Safety Clause)

**コンテキスト削減が正確性を危険にさらす場合**:
→ より多くのコンテキストを要求する。

**低信頼度の結果を静かに生成してはいけない**。

## 10. AIへの指示例 (AI Instructions)

### 10.1 レビュー依頼時

```
「このPRのコードをレビューして。【DIFF】git diffを優先して、変更箇所のみをレビューして。セキュリティとエッジケースの観点で [MUST] な問題があれば指摘して。」
```

### 10.2 実装依頼時

```
「この機能を実装して。【MC】変更対象ファイルと直接の依存関係のみを読み込んで。巨大ファイルは範囲指定で必要な箇所のみ読み込んで。」
```

### 10.3 調査依頼時

```
「この機能はどこで実装されているか調査して。codebase_searchで関連ファイルを特定してから、必要箇所のみを読み込んで。」
```

---

## 11. 参考: 既存ルールとの関係

- **`22-tool-usage-policy.mdc`**: 並列実行のガイドラインを補完。コンテキスト最適化の観点を追加。
- **`44-subagent-usage.mdc`**: サブエージェント使用基準を補完。モデル選択と役割分担の観点を追加。
- **`36-code-review-guidelines.mdc`**: レビュー観点を補完。コンテキスト最適化の観点を追加。

---

## 12. まとめ: 実装時の必須チェックリスト

### タスク受領時
- [ ] タスクの性質を分析し、最適なモデルを選択
- [ ] 必要なコンテキスト量を推定
- [ ] 読み込み戦略を決定（範囲指定、並列実行）

### コンテキスト読み込み時
- [ ] 巨大ファイル（1000行超）は範囲指定
- [ ] 関連性のないファイルは読み込まない
- [ ] 並列実行可能な読み込みは並列実行
- [ ] 同じファイルを複数回読み込まない

### タスク完了時
- [ ] 無駄なコンテキスト消費がなかったか確認
- [ ] 最適なモデルを選択できたか確認
- [ ] 役割分担が適切だったか確認
