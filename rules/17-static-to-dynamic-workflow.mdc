---
alwaysApply: false
---
Description: 静的なHTML/CSSのコードを、データと連携する動的なReactアプリケーションに変換するための、ステップ・バイ・ステップのワークフローです。このプロセス全体をガイドします。「このHTMLを動的にしたい」といった依頼があった場合に、このルールを適用してください。

# ワークフロー: 静的UIから動的アプリケーションへ

## ステップ1: 静的コードの解析とコンポーネント化計画
- **目的**: まずは既存の静的コード（HTML/CSS）を理解し、どの部分を再利用可能なコンポーネントに切り出すべきかを計画します。
- **AIへの指示**:
  1. 「このHTMLとCSSのコードを読み込んで。これをReactコンポーネントに分割していく計画を立てたい。」
  2. 「このコードの中で、繰り返し使われているパターン（例: 商品カード、リストの項目）はどれかな？それらをまずコンポーネント候補としてリストアップして。」
  3. 「このデザインの一貫性を保つために、`01-design-system.mdc`で定義した色やスペーシングを適用しながらコンポーネント化を進めたい。」

## ステップ2: コンポーネントの実装
- **目的**: 計画に基づき、静的なHTMLを再利用可能なReactコンポーネントに変換します。この際、データはまだ固定値（ハードコーディング）で構いません。
- **AIへの指示**:
  1. 「さっきリストアップした商品カードの部分を、`ProductCard.tsx`という名前のReactコンポーネントとして切り出して。受け取るデータはまだ固定でいい。」
  2. 「このコンポーネントのCSS、Tailwind CSS（またはプロジェクトで使うCSS手法）に書き換えつつ、デザインシステムの色やスタイルを適用してほしい。」

## ステップ3: データ契約の定義
- **目的**: 作成したコンポーネントが必要とするデータは何かを明確にし、バックエンドが提供すべきAPIの仕様（＝契約）を定義します。
- **AIへの指示**:
  1. 「今作った`ProductCard.tsx`コンポーネントが動的に変わるためには、どんなデータが必要かな？Propsの型定義をTypeScriptで作成して。」
  2. （AIの提案: `type Product = { id: string; name: string; price: number; imageUrl: string; }`）
  3. 「ありがとう。では、この`Product`の配列を返すAPIのエンドポイントを`/api/products`として定義しよう。」

## ステップ4: バックエンドAPIの実装
- **目的**: ステップ3で定義した契約に基づき、実際にデータを返すバックエンドのAPIを実装します。
- **AIへの指示**:
  1. 「`07-nodejs-best-practices.mdc`と`08-supabase-rules.mdc`のルールに従って、`/api/products`のエンドポイントをNode.js/Expressで実装して。」
  2. 「Supabaseの`products`テーブルからデータを取得し、ステップ3で定義した`Product`型の配列としてレスポンスを返すようにしてほしい。」

## ステップ5: フロントとバックの最終接続（Wiring）
- **目的**: フロントエンドのコンポーネントから、実装されたバックエンドAPIを呼び出し、ハードコーディングされていたデータをAPIからのレスポンスに置き換えます。これでアプリケーションに命が吹き込まれます。
- **AIへの指示**:
  1. 「商品一覧を表示するページコンポーネントで、今作った`/api/products`エンドポイントからデータを`useEffect`で取得するようにして。」
  2. 「取得した商品データの配列を`.map()`でループさせて、`ProductCard`コンポーネントを商品ごとに表示するように書き換えて。ローディングとエラーの状態も考慮してね。」